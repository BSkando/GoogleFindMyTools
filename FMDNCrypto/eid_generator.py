from Crypto.Cipher import AES
from ecdsa import SigningKey, SECP160r1

from FMDNCrypto.util import hexadecimal

# Constants
K = 10
ROTATION_PERIOD = 1024  # 2^K seconds
EID_COUNT = 1000

def calculate_r(identity_key, timestamp):
    # Prepare the data structure
    ts_bytes = timestamp.to_bytes(4, 'big')
    identity_key_bytes = hexadecimal(identity_key)

    # A random is generated by AES-ECB-256 encrypting the following data structure with the ephemeral identity key:
    data = bytearray(32)
    data[0:11] = b'\xFF' * 11
    data[11] = K
    data[12:16] = ts_bytes
    data[16:27] = b'\x00' * 11
    data[27] = K
    data[28:32] = ts_bytes

    # AES-ECB-256 encryption
    cipher = AES.new(identity_key_bytes, AES.MODE_ECB)
    r_dash = cipher.encrypt(bytes(data))

    # Convert r' to an integer
    r_dash_int = int.from_bytes(r_dash, byteorder='big', signed=False)

    # SECP160R1 parameters
    curve = SECP160r1
    n = curve.order

    # r' is now projected to the finite field Fp by calculating r = r' mod n
    return (r_dash_int % n)


def generate_eid(identity_key, timestamp):
    # Calculate r
    r = calculate_r(identity_key, timestamp)

    # Compute R = r * G
    curve = SECP160r1
    R = r * curve.generator

    # Return the x coordinate of R as the EID
    return R.x()
